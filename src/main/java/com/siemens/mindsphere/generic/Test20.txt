【代码清单】
cn.itcast.api.a.generic
	|--GenericDemo.java ： 引出泛型，在程序中的使用和作用。
	|--GenericDemo2.java：泛型类的使用。
	|--GenericDemo3.java：泛型方法的使用。
	|--GenericDemo4.java：泛型接口的使用。
	|--GenericDemo5.java：泛型通配符的使用。
	|--GenericDemo6.java：泛型的限定的使用。
	|--GenericDemo7.java：通配符在api中的体现和使用。
	|--GenericDemo8.java：泛型上限在api中的体现和使用。
	|--GenericDemo9.java：泛型下限在api中的体现和使用。
	|--GenericDemo10.java：泛型细节：保证两边泛型值一致。
	|--GenericTest.java：对字符串按照长度排序，比较器用匿名内部类完成。想要逆序，只要将o1和o2比，改成o2和o1比。
	|--GenericTest2.java：获取集合元素最大值，1，指定类型  2，Object类型，3，泛型限定。★★★★★


【第20天 总结】
	【阶段一】
		【目标：泛型的由来和基本使用】
			1，因为集合可以存储的对象类型是任意的，在取出进行向下转型时，容易发生ClassCastException。
			所以JDK1.5以后就有了解决这个问题的技术：泛型。
			2，泛型的原理：其实就是在操作的元素类型不确定时，通过传递参数的形式来明确类型。
			3，泛型的体现就是 <参数类型变量>用于接收具体的实际元素类型。
			4，泛型技术在集合框架中应用非常广泛，只要记住：在使用类或者接口时，如果接口上有明确<>泛型。
			在使用时，就传递所需的数据类型即可。不传递会出现警告类型不安全提示。
			5，了解：泛型技术是用在编译器部分的技术，一旦类型检查正确，
				生成的class文件中就没有泛型标记了：这是的泛型的擦除。
			6，泛型的好处：
				6.1 将运行时期的ClassCastException异常转移到编译时期通过编译失败体现。
				6.2 避免了强制转换的麻烦。
			7，其实泛型的使用就是往定义了泛型的类或者接口的<>中传递类型参数。
		【学习结果】
			1，表述出泛型技术的特点和好处。
			2，泛型在集合对象中的使用，要求写集合代码时必须加入泛型。★★★★★
	------------------------
	【阶段二】
		【目标：自定义泛型】
			1，没有泛型之前，对于不确定的对象类型，是通过Object类型多态方式解决的。
			弊端：当对象提升为Object后，需要向下转型才可以使用对象的内容。
			而转型就会有运行发生ClassCastException异常的风险。
			2，有了泛型后，将不确定的类型定义成参数，把Object替换成参数类型。
			好处是：调用者在使用时必须先明确类型，如果操作的对象类型不符符合，直接编译失败。
					类型符合，使用对象特有方法时，不需要进行强制转换。
			参阅GenericDemo2.java
			3，泛型类，泛型方法，泛型接口的体现。
			4，注意：
				4.1 类上的泛型是在创建该类对象时进行类型明确。
				4.2 静态方法无法访问类上定义的泛型，如果需要泛型，只能定义在方法上。

		【学习结果】
			1，了解泛型类，泛型方法，泛型接口的定义体现形式。
			2，自定义泛型类，体会泛型前和泛型后的区别★★★★★

	------------------------
	【阶段三】
		【目标：通配符和泛型的限定】
			1，当使用了带有泛型的类时，需要传递具体类型实参时，无法明确要传递的实参，可以用？通配符表示。
			2，如果要操作的对象的类型是在一个范围之内，比如只操作Person或者Person的子类型对象时。
			这时可以使用泛型的限定，对要操作的类型进行限制，提高程序类型操作的安全性。
			3，泛型限定体现：
				? extends E :接受E类型或者E的子类型。上限。
				? super E   ：接受E类型或者E的父类型。下限。
			4，在api中的体现，要求看懂，并理解使用的原因。★★★★★
				4.1 通配符的api体现：
				Collection中的containsAll(Collection<?> c):因为该方法内部使用的是equals方法，
				而equals(Object)方法是可以和任意对象进行比较，所以传递进来的集合元素是什么类型都可以，
				无法确定具体的类型参数用？表示。

				4.2 上下限api的体现。TreeSet集合的构造函数。
				TreeSet(Collection<? extends E> c) ：在给TreeSet集合初始化元素时，
				传递进来的容器中的元素类型只要时TreeSet集合明确的类型或者子类型都可以。

				TreeSet(Comparator<? super E> comparator) ：在明确TreeSet比较器时，
				只要是TreeSet集合元素类型的比较器，或者该元素类型的父类型都接收元素对象进行比较。
			5，泛型限定的练习。★★★★★
				获取Collection集合中的最大值。
				5.1 先定义了一个方法中明确具体元素类型的getMax_1。
				5.2 由于getMax_1无法获取其他类型元素的最大值。提高扩展性，操作所有对象。
				就升级为了Object 。getMax_2
				5.3 因为定义成Object，什么类型都可以接收，容易出现运行时的ClassCastException
				所以使用泛型，对要操作的元素进行类型的限定。只有Comparable的子类才可以进行获取最值的操作。
				public static <T extends Comparable<? super T>> T getMax_3(Collection<? extends T> c);

		【学习结果】
			1，看懂泛型限定在API中的体现，并会使用带有泛型限定的方法。
			2，完成Collection集合最大值的获取，带有类型限定。★★★★★

	------------------------
	【阶段四】
		【目标：集合框架的工具类】
			1，为了解决集合的更多需求。集合框架提供了Collections和Arrays两个工具类，方法都是静态的。
			2，Collections是用于操作集合的工具类。
				常见方法：对List集合排序，二分查找，对Collection集合进行最值获取。
				对排序进行逆序，将非同步的集合转成同步的集合。
			3，Arrays对数组操作的工具类：
				常见方法：对数组排序，二分查找，数组复制，将数组转成字符串等。
			4，数组集合互转。
				4.1将数组转成集合 Arrays.asList方法。
					目的：使用集合的方法操作数组元素。
					注意：不要使用集合的增删方法。因为数组转成List集合后长度是固定的。
					     转成集合的数组中存储的元素最好是对象，如果是基本数据类型，会将这个数组作为元素存储到集合中。
				4.2 集合转成数组。
					Collection接口中的toArray方法。
					目的：限定对元素的增删，长度的改变。

		【学习结果】
			1，了解这个两个工具类的常用功能。
			2，对常用功能进行练习。
	------------------------




【作业】
1，Collection和Collections的区别？【面试题】
Collection是集合框架的顶层接口。
	下面有两个开发中常用的List 和 Set集合。
	根据数据结构的不同，也有了很多的具体子类集合对象。

Collections：是集合框架中的用于操作集合的工具类。
	提供了很多的静态方法：比如：对list排序，二分查找，比如可以获取最值等。
	其中一组可以非同步集合转成同步 集合的方法。


2，对List集合中存储的重复字符串元素，按照长度进行排序。


3，在一个已排序的List集合中插入一个字符串，继续保证这个集合原有排序，问如何获取这个位置。【面试题】
使用到了二分查找。


4，定义一个通用的(带泛型)获取集合最大值的方法。


5，一个ArrayList对象alist中存有若干个字符串元素，现欲遍历该ArrayList对象，
删除其中所有值为"abc"的字符串元素，请问下面的实现正确么？如有问题，
会出现什么问题？如何更正？

int size = alist.size();
for(int i = 0; i < size; i++) {
  if("abc".equals(alist.get(i))) {
    alist.remove(i);
  }
}


要准备提交 集合框架的总结文档！





